<resources>
    <string name="app_name">Изучение Java</string>
    <string name="client_id">2221e68c08565b4e83a6dea0a1387ac6</string>
    <string name="client_secret">2281fad10c32076a0d1ae232ed282ff209b7bbb1d92b9650dd6666d5c0f336c1</string>
    <string name="language">java</string>
    <string name="title_home">Прогресс</string>
    <string name="title_theory">Теория</string>
    <string name="title_practice">Практика</string>
    <string name="daily_progress">Дневная\nцель</string>
    <string name="daily_progress_indicator_text">2/4</string>
    <string name="tasks_done">Заданий\nсделано</string>
    <string name="theory_read">Теории\nпрочтено</string>
    <string name="cheer_0">Постарайтесь, у вас все получится!</string>
    <string name="cheer_30">Неплохо, я в вас верю!</string>
    <string name="cheer_70">Ещё немного до дневной цели :)</string>
    <string name="cheer_100">Хорошая работа, отдохните ^-^</string>
    <string name="difficulty_low">низкая</string>
    <string name="difficulty_mid">средняя</string>
    <string name="difficulty_high">высокая</string>
    <string name="seekbar_amount_text">Цель (заданий в день): %1$d</string>
    <string name="seekbar_difficulty_text">Сложность: %1$s</string>
    <string name="theory_1"># Теоретический материал 1. Введение.\n
        Для того чтобы увидеть результат программы, пусть даже самой простой, нужно:\n
- написать программу. Для этого нужно владеть языком программирования, причем знать не только синтаксис, но и возможности так называемых библиотек, уметь пользоваться текстовым редактором, при необходимости установить его, сохранить файл на диске;\n
- скомпилировать. Процессор понимает только машинные команды, поэтому нужно перевести текст программы в числовые коды. Это не всегда происходит сразу после написания кода. Во многих языках программирования окончательная компиляция происходит уже в процессе выполнения программы;\n
- в случае, если программа разрабатывается для другого устройства, загрузить откомпилированный (или частично откомпилированный код) на устройство. Для этого нужно связаться с устройством, использовать протоколы передачи информации;\n
- запустить программу на выполнение.\n
\nДля того чтобы на хорошем уровне понимать детали этого процесса, нужно учиться не один год. И тем не менее, мы напишем, скомпилируем, загрузим и запустим первую программу уже на этом занятии. Как это возможно? Существует много средств для облегчения труда разработчиков. При этом нужно постоянно осознавать, что нужно понимать, как «оно устроено внутри». Мы будем возвращаться и рассматривать детали постепенно.
Прежде всего, главный инструмент разработчика — это среда программирования (еще называют «среда разработки»). Для эффективной работы необходимо хорошо представлять ее возможности и постоянно пользоваться ими. Программа обучения содержит свою среду разработки.
Структура программы, имеющей обычный, "консольный" вид выглядит так:\n
```\n
public class MyProgram{\n
\tpublic static void main(String[] args) {\n
\t\tSystem.out.println("Hello, world!");\n
\t}\n
}\n
```\nПотренируйтесь, решая практическое задание 1.</string>


    <string name="theory_3"># Теоретический материал 3. Ввод из консоли.\n Ввод в языке Java может осуществляться многими способами: существуют классы-потоки (Stream) для чтения из любого источника,
    но на текущий момент нам интересен ввод из консоли самым простым и удобным образом. И для этого программисты, работающие над языком Java, создали Scanner - удобный класс, используемый для чтения из любого потока.
     Потоком в нашем случае будет являться System.in - входной поток консоли. Создать объект Scanner можно следующим образом:\n```\n
    Scanner s = new Scanner(System.in);\n```\n(Оператор new возвращает указатель объект конструктора)\n
    Для того, чтобы считать число, воспользуйтесь методом s.nextInt() (где s - объект ранее созданного Scanner-а), который возвращает целочисленное значение типа int, для считывания строки
    можно использовать s.nextLine() (возвращает строку String) и s.next()  для того, чтобы получить ввод до пробела (Возвращает строку String).
    Для считывания double подойдет метод s.nextDouble()\n P.S. Для использования сканера нужно его импортировать:\n```\nimport java.util.Scanner;\n```\n (импорты находятся перед заголовком файла)</string>
    <string name="theory_2"># Теоретический материал 2. Типы данных.\nВ Java типы данных объявляются
    следующим образом:\n```\n\&lt;тип&gt; &lt;имя переменной&gt; [ = &lt;значение&gt;];\n```\n
    Как и в C++, они могут быть сначала объявлены, а уже потом - проинициализированы:\n```\nint a;\na=5;\n```\n
    Говоря только о примитивных (не ссылочных) типах, в Java они бывают следующие:\n
    * Целые числа - byte, short, int, long.\n
    * Числа с плавающей точкой (иначе вещественные) - float, double.\n
    * Логический - boolean.\n
    * Символьный - char.\n
    Ссылочные же типы - типы данных, инициализируемые с помощью объекта new и хранящие в себе ссылку
    на объект, а не сам объект. При присвоении новому объекту значения другого, ему будет присвоена
    ссылка, а объект не будет скопирован, как того ожидают некоторые пользователи.</string>
    <string name="theory_4"># Теоретический материал 4. Циклы.\nВ java, как и в C++, имеются циклы,
    имеющие абсолютно идентичный вид (т.к., напомню, Java- си-подобный язык). Циклы позволяют в зависимости от определённых условий выполнять определённое действие множество раз. В Java есть следующие виды циклов:\n
    * for\n
    * while\n
    * do..while\n ## Циклы for\n Определяются следующим образом:\n```\nfor([иниц. счётчика]; [условие]; [изменение счётчика]) {\n// действия\n}\n```\nСтандартный счётчик выглядит так:\n
    ```\n
        for(int i = 0; i &lt; 5; i++) {\n
        System.out.print(i);\n}\n
    ```\n Он выведет следующее: "01234"\n ## Циклы do\n Пример цикла do выглядит так:\n```\n
    int counter = 0;\n
        // Посчитаем 500 овец, переходящих через мост.\n
        do {\n
        System.out.println((counter+1) + " овец прошло через мост");\n
        counter++; // Инкремент - увеличивает число на 1\n
    }\n while(counter &lt; 500)\n ```\n ## Цикл while\n То же самое, что и do while, только условие
    проверяется перед циклом. Пример:\n```\n
    int counter = 0;\n
        // Посчитаем 499 овец, переходящих через мост.\n
        while(counter &lt; 500) {\n
        System.out.println((counter+1) + " овец прошло через мост");\n
        counter++; // Инкремент - увеличивает число на 1\n
    }\n ```\n ## Операторы continue и break\nЭти операторы помогут вам остановить или продолжить
    цикл со следующей итерации. continue продолжает цикл со след. итерации, прерывая текущую,
    а break прерывает цикл полностью. Пример:\n```\nfor(int i = 0; i &lt; 5; i++) {\n
    if (i == 2) continue;\n System.out.print(i)\n}\n```\nЭтот цикл выведет все числа от 0 до 4,
        кроме двойки: "0134"</string>
    <string name="theory_5"># Теоретический материал 5. Логические операторы.\nВ Java есть следующие логические операторы:\n
    * &amp;	Логическое AND (И)\n
* &amp;&amp;	Сокращённое AND\n
* |	Логическое OR (ИЛИ)\n
* ||	Сокращённое OR\n
* ^	Логическое XOR (исключающее OR (ИЛИ))\n
* !	Логическое унарное NOT (НЕ)\n
* &amp;=	AND с присваиванием\n
* |=	OR с присваиванием\n
* ^=	XOR с присваиванием\n
* ==	Равно\n
* !=	Не равно\n
* ?:	Тернарный (троичный) условный оператор\n&lt;br&gt;\n\nКак и в C++, эти операции могут выполняться как над
    переменными типа boolean, так и над числами (в качестве побитовых операций).</string>
    <string name="theory_6"># Теоретический материал 6. Непримитивные типы.\nВ Java, кроме примитивных типов, бывают также непримитивные.\nНепримитивными типами данных являются те типы данных,
    доступ к которым можно получить только с помощью ссылки. Если вы знакомы с концепцией наследования, то все непримитивные объекты наследуются от класса Object. Таким образом, любой непримитивный объект -
    объект, который реализует весь функционал Object. Хранится при этом в переменной не экземпляр объекта, а ссылка на экземпляр объекта в памяти, поэтому при передаче его в функцию, новый объект не создается:
     функция получает доступ к старому объекту.\nИнициализирован любой объект может быть с помощью new, причем конструктор может быть как параметризированным, так и стандартным:\n```\nObject object = new Object();\nString string = new String("Hello world!");\n```\n
    </string>
    <string name="theory_7"># Теоретический материал 7. Массивы.\nВ Java также существуют массивы, использование
        которых часто требуется в процессе решения задач. В Java массив из любых объектов (будь то примитивные типы данных или ссылочные) обозначается добавлением
    квадратных скобок ([]) после указания типа данных, которые будут храниться в массиве. Массив - ссылочный тип, так что инициализировать его нужно с помощью оператора new следующим
    образом:\n```\nint[] array = new int[10];\n```\n. В квадратных скобках после оператора new нужно указать размер массива.\nМожно также инициализировать его другим способом, задав значения:\n
    ```\nint[] array = {1,2,3,4,5,6,7,8,9,10};\n```\nТеперь элементы массива будут инициализированы заранее указанными значениями.\nВажно! Если тип примитивный, то он не может принимать значение null,\n
     следовательно, примитивные типы всегда инициализируются с определенным значением (у логических переменных - false, у целых - 0 и т.д.)</string>
    <string name="theory_8"># Теоретический материал 8. Строки\nСтроки в Java являются непримитивным типом, что немного (но не сильно) усложняет работу с ними. Если сравнивать их с помощью оператора ==, то будут сравнены ссылки на объекты, а не сами строки.\n
    Следовательно, одинаковые по содержанию, но располагающиеся в разных местах памяти строки не будут равны. Для сравнения строк у класса String существует нестатичный (вызываемый на объекте строки) метод .equals(), в качестве параметра в который нужно передать строку, с которой
     будет сравнён объект, на котором вызывался этот метод. Инициализировать же строки легко следующим образом:\n```\nString string = "Hello world!"\n```\n</string>
    <string name="task_title">Решение задачи</string>
    <string-array name="theory">
        <item>@string/theory_1</item>
        <item>@string/theory_2</item>
        <item>@string/theory_3</item>
        <item>@string/theory_4</item>
        <item>@string/theory_5</item>
        <item>@string/theory_6</item>
        <item>@string/theory_7</item>
        <item>@string/theory_8</item>
    </string-array>

</resources>
